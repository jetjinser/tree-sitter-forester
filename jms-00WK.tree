\title{Forester 4.2}
\date{2024-06-20}
\author{jonmsterling}
\contributor{kentookura}
\contributor{jinserkafka}
\taxon{release}

\p{This release brings several internal changes that are meant to facilitate the further improvement of [[jms-005P]], as well as some user-facing changes (most notably a [new query language](jms-00WS)). These are breaking changes: existing queries will need to be translated, and you will need to upgrade your theme.}

\subtree[jms-00YF]{
 \title{first-class functions and lazy arguments}

 \p{This release adds λ-abstraction, which can be written like so:}

 \pre\verb<<|
\fun[x][y]{Hello, \x and \y}
 <<

 \p{In addition, \em{lazy} arguments are now supported. In any place that a function argument can be bound (e.g. in \code\verb<<|\def<<, \code\verb<<|\let<<, or \code\verb<<|\fun<<), an argument marked with a tilde is automatically wrapped in a thunk when it is passed. For example, consider the following code:}

 \pre\verb<<|
\def\my-fun[x][~y]{Hello, \x and \y{}!}

\p{\my-fun{foo}{bar}}
 <<

 \p{In the above, the argument \code{x} is strict and \code{y} is a thunk that must be forced before being used—hence the application to \code{{}}; note that the results are not memoised. The code above is functionally equivalent to the following:}

 \pre\verb<<|
\def\my-fun[x][y]{Hello, \x and \y{}!}

\p{\my-fun{foo}{\fun[z]{bar}}}
 <<

 \p{Of course, when your code is pure, passing by name \em{vs.} by value does not make a difference. The purpose of this feature is, however, to enable more expressive macros that make use of fluid bindings.}

 \subtree[jms-00YG]{
  \taxon{example}
  \title{combining fluid bindings and lazy arguments}
  \let\relax[x]{\x}

  \p{[Forester 4.0’s enhanced XML support](jms-00RH) makes it possible (see \ref{jms-00RL}) to write [[jms-00YE]] directly as an alternative to using [[jms-005P]]’s TeX-like math mode via KaTeX. For example, we can write the following wrappers for some basic [[jms-00YE]] elements:}

  \pre\verb<<|
\xmlns:mml{http://www.w3.org/1998/Math/MathML}
\def\math[body]{\<mml:math>{\body}}
\def\mrow[body]{\<mml:mrow>{\body}}
\def\mi[x]{\<mml:mi>{\x}}
\def\mo[o]{\<mml:mo>{\o}}
\def\mn[n]{\<mml:mn>{\n}}
  <<

  \p{With this in hand, we can write prose involving [[jms-00YE]] content, like so:}

  \pre\verb<<|
\p{Let \math{\mi{x}} and \math{\mi{y}} be integers such that \math{\mrow{\mrow{\mi{x}\mo{-}\mi{y}}\mo{=}\mn{0}}}.}
  <<

  \p{The above is a bit messy. We can clean it up with some function definitions:}

  \pre\verb<<|
\def\plus[x][y]{\mrow{\x \mo{+} \y}}
\def\equals[x][y]{\mrow{\x \mo{=} \y}}
\let\x{\mi{x}}
\let\y{\mi{y}}

\p{Let \math{\x} and \math{\y} be integers such that \math{\equals{\plus{\x}{\y}}{\mn{0}}}.}
  <<

  \p{It is annoying that we have to always wrap things in \code\verb<<|\math<<. By combining first-class functions, lazy arguments, and fluid bindings, we can lift this requirement:}

  \pre\verb<<|
% Allocate a fluid binding to hold the function that enters math mode.
\alloc\math-wrapper

% Ensure that a given (lazy) argument is evaluated inside a
% <mml:math> element.
\def\ensure-math[~body]{%
 \scope{%
  % Set a default value for \math-wrapper (no-op if already set).
  \put?\math-wrapper{\fun[x]{\<mml:math>{\x}}}%
  %
  % Apply the current function bound to \math-wrapper.
  \get\math-wrapper{%
   % Bind \math-wrapper to the identity function in the current scope so that
   % we do not get redundant <mml:math> nodes.
   \put\math-wrapper{\fun[x]{\x}}%
   %
   % Force the \body thunk to evaluate the body within the wrapper.
   \body{}%
  }%
 }%
}
  <<

  \p{We now re-define our macro library to use the \code\verb<<|\ensure-math<<:}

  \pre\verb<<|
\def\mrow[~x]{\ensure-math{\<mml:mrow>{\x{}}}}
\def\mi[~x]{\ensure-math{\<mml:mi>{\x{}}}}
\def\mo[~x]{\ensure-math{\<mml:mo>{\x{}}}}
\def\mn[~x]{\ensure-math{\<mml:mn>{\x{}}}}
\def\plus[~x][~y]{\mrow{\x{} \mo{+} \y{}}}
\def\equals[~x][~y]{\mrow{\x{} \mo{=} \y{}}}
  <<

  \p{Now, we can put [[jms-00YE]] content freely into prose without needing to wrap it each time.}

  \pre\verb<<|
\let\x{\mi{x}}
\let\y{\mi{y}}

\p{Let \x and \y be integers such that \equals{\plus{\x}{\y}}{\mn{0}}.}
  <<
 }

 \subtree[jms-00YH]{
  \taxon{warning}
  \title{lazy arguments are experimental}
  \p{Please note that these features are experimental and subject to change—only build large macro libraries relying on them at your own risk.}
 }
}


\subtree[jms-00WS]{
 \title{new query language}

 \p{The existing querying feature, [introduced in Forester 2.2](jms-0066), has been replaced by something much better — at the cost of a breaking change that will require existing queries to be rewritten.}

 \subtree[jms-00WU]{
  \title{new syntax for set operations}
  \p{Intersections of queries are formed using a \em{variadic} constructor \code\verb<<|\query/isect<<. For example, the following computes the intersection of the queries \code{q1}, \code{q2}, and \code{q3}:}

  \pre\verb<<|
\query/isect{q1}{q2}{q3}
  <<

  \p{Unions of queries are formed similarly using the variadic \code\verb<<|\query/union<< constructor. The complement of a query \code{q} is written \code\verb<<|\query/compl{q}<<.}

  \p{\strong{Note:} as before, to render the results of a query you must use the \code\verb<<|\query<< command; for example:}

  \pre\verb<<|
\query{
 \query/isect{q1}{q2}{q3}
}
  <<
 }

 \subtree[jms-00WV]{
  \title{query operations are first-class values}
  \p{Previously, the built-in query operations were written like \code\verb<<|\query/and<<, etc.; these names, however, were hard-coded into the lexer which meant that they did not work in the expected way with [[jms-005P]]’s hierarchical namespacing. This hardcoding has been removed, and query operations are treated as first-class values that are resolved from primitive names in the \code\verb<<|\query/<< namespace. As such, the following code is equivalent to \code\verb<<|\query/compl{\query/taxon{theorem}}<<:}

  \pre\verb<<|
\scope{
 \open\query
 \compl{\taxon{theorem}}
}<<

  \p{A further consequence of this change is that queries can be defined compositionally by macros.}
 }

 \subtree[jms-00WW]{
  \title{relational queries}

  \p{The most significant user-facing change to the query language is the ability to form basic \em{relational} queries along several [built-in relation-symbols](jms-00WX); in fact, the built-in query constructors \code\verb<<|\query/taxon<<, \code\verb<<|\query/tag<<, and \code\verb<<|\query/author<< are all expressible in these terms.}

  \subtree[jms-00WX]{
   \title{built-in relation symbols}

   \p{[[jms-005P]] includes several built-in relation symbols, maintained as graphs that are accumulated during evaluation:}
   \ul{
    \li{\code\verb<<|\rel/transclusion<< contains an edge from \code{x} to \code{y} when \code{x} directly transcludes \code{y}, i.e. contains \code\verb<<|\transclude{y}<<.}
    \li{\code\verb<<|\rel/links<< contains an edge from \code{x} to \code{y} when \code{x} links to \code{y}, i.e. contains something like \code\verb<<|[...](y)<< or \code\verb<<|[[y]]<<.}
    \li{\code\verb<<|\rel/taxa<< contains an edge from \code{x} to \code{y} when \code{x} has taxon \code{y}, i.e. contains \code\verb<<|\taxon{y}<<.}
    \li{\code\verb<<|\rel/tags<< contains an edge from \code{x} to \code{y} when \code{x} has tag \code{y}, i.e. contains \code\verb<<|\tag{y}<<.}
    \li{\code\verb<<|\rel/authors<< contains an edge from \code{x} to \code{y} when \code{x} has author \code{y}, i.e. contains \code\verb<<|\author{y}<<.}
    \li{\code\verb<<|\rel/contributors<< contains an edge from \code{x} to \code{y} when \code{x} is a tree with contributor \code{y}, i.e. contains \code\verb<<|\contributor{y}<<.}
   }

   \p{The implementation supports arbitrarily many relation symbols; this is not yet exposed to the user, but could in the future be employed by advanced users of [[jms-005P]] to support the development of sophisticated ontologies.}
  }

  \subtree[jms-00WZ]{
   \title{query modes and polarities}
   \p{Given an address \code{x} and a relation symbol \code{r}, there are several useful queries that we might wish to make:}
   \ol{
    \li{We might wish to find all \em{incoming} edges to \code{x} in \code{r}, or we may wish to find all \em{outgoing} edges from \code{x} in \code{r}. We shall refer to the differenec between incoming and outgoing edges is referred to as a \em{polarity}.}
    \li{Rather than searching for edges, we may wish to search for \em{paths} — which corresponds to passing from a relation to its preorder reflection. We will refer to this distinction as a \em{mode}.}
   }

   \p{[[jms-005P]] supports both polarities and modes for relational queries via the following built-in constants:}
   \ol{
    \li{\code\verb<<|\query/incoming<< and \code\verb<<|\query/outgoing<< denote the two polarities.}
    \li{\code\verb<<|\query/edges<< and \code\verb<<|\query/paths<< represent the two modes.}
   }
  }

  \subtree[jms-00WY]{
   \title{the syntax of a relational query}

   \p{A relational query takes the following form:}

   \pre\verb<<|
\query/rel{mode}{polarity}{relation}{addr}
   <<

   \p{In the above, \code{mode} and \code{polarity} must evaluate to mode and polarity constants as in \ref{jms-00WZ}; \code{relation} must evaluate to a relation symbol as in \ref{jms-00WX}.}
  }

  \subtree[jms-00X0]{
   \taxon{example}
   \title{expressing built-in queries}

   \p{The built-in basic queries can be expressed in terms of [\code\verb<<|\query/rel<<](jms-00WY) in the following way:}

   \pre\verb<<|
\def\my-query/author[x]{
 \open\query
 \rel{\edges}{\incoming}{\rel/authors}{\x}
}

\def\my-query/taxon[x]{
 \open\query
 \rel{\edges}{\incoming}{\rel/taxa}{\x}
}

\def\my-query/tag[x]{
 \open\query
 \rel{\edges}{\incoming}{\rel/tags}{\x}
}
    <<
  }

  \subtree[jms-00X2]{
   \taxon{example}
   \title{querying the (back)links and context a given tree}

   \p{Both the backlinks and (forward) links of a given tree can be computed using a query to the \code\verb<<|\rel/links<< relation, and the context (immediate parents) of a given tree can be obatined from the \code\verb<<|\query/transclusion<< relation:}

   \pre\verb<<|
\def\query/backlinks[x]{
 \open\query
 \rel{\edges}{\incoming}{\rel/links}{\x}
}

\def\query/links[x]{
 \open\query
 \rel{\edges}{\outgoing}{\rel/links}{\x}
}

\def\query/context[x]{
 \open\query
 \rel{\edges}{\incoming}{\rel/transclusion}{\x}
}<<
  }


  \subtree[jms-00X4]{
   \taxon{example}
   \title{querying a coslice of the transclusion preorder}

   \p{We can also write a query to compute the set of trees \em{underneath} a given tree in the transclusion preorder (including the original tree) — in other words, the coslice.}

   \pre\verb<<|
\def\query/transclusion-coslice[x]{
 \open\query
 \rel{\paths}{\outgoing}{\rel/transclusion}{\x}
}<<
  }
 }

 \subtree[jms-00X1]{
  \title{unions and intersections of families of queries}

  \p{A further primitive query-former is the union or intersection of a certain \em{family} of queries indexed in the \em{results} of a fixed query. These are written as follows:}

  \pre\verb<<|
\query/union-fam{q}{qfam}
\query/isect-fam{q}{qfam}
  <<

  \p{In the above, \code{q} is a query expression and \code{qfam} is a [\em{first-class function}](jms-00YF) that takes an address and returns a query expression. There are a couple built-in instantiations of \code\verb<<|\query/union-fam<< and \code\verb<<|\query/isect-fam<< for the specific case where \code{qfam} is a family of \em{relational} queries; for example:}

  \pre\verb<<|
\query/union-fam-rel{q}{mode}{polarity}{rel}
  <<

  \p{is equivalent to the following more verbose code:}

  \pre\verb<<|
\query/union-fam{q}{
 \fun[x]{
  \query/rel{mode}{pol}{\x}
 }
}
  <<

%   \p{The meaning of the above is to first compute the set of trees \code{x,...} satisfying the query \code{q}, and then take the (union, intersection) of all the induced relational queries \code\verb<<|\query/rel{mode}{polarity}{relation}{x}<<. With this feature in hand, it becomes possible to compute the full bibliography of a given tree, or find the full list of contributors to a given tree (as opposed to only its immediate contributors).}


  \subtree[jms-00X3]{
   \taxon{example}
   \title{querying the bibliography of a given tree}

   \p{We can define a macro to compute the bibliography of a given tree, making use of \code\verb<<|\query/transclusion-coslice<< from \ref{jms-00X4}.}

   \pre\verb<<|
\def\query/bibliography[x]{
 \open\query
 \isect{
  \union-fam-rel{\transclusion-coslice{\x}}{\edges}{\outgoing}{\rel/links}
 }{
  \taxon{reference}
 }
}
   <<

   \p{The above code first accumulates all the outgoing links from the given tree and any of its children, and then restricts (by intersection) to those with taxon \code{reference}.}
  }

  \subtree[jms-00X5]{
   \taxon{example}
   \title{querying all hereditary contributors to a tree}

   \p{We can use the union of families of relational queries to compute the set of (proper) [\em{contributors}](tfmt-000T) to a given tree. This is slightly subtle, because if a bibliographic tree is transcluded, we do not want its contributors to be included.}

   \pre\verb<<|
\def\query/contributors[x]{
 \open\query
 \union-fam-rel{
  \isect{
   \transclusion-coslice{\x}
  }{
   \compl{
    \taxon{reference}
   }
  }
 }{\edges}{\outgoing}{\rel/contributors}
}<<
  }

  \p{In the future, the support for query-indexed families of queries might be generalised to allow arbitrary queries in the components rather than only relational ones. The current version of the feature should be viewed as somewhat provisional.}
 }


 \subtree[jms-00WT]{
  \taxon{warning}
  \title{queries are experimental}
  \p{It is strongly recommended that inexperienced users of [[jms-005P]] continue to limit their usage of queries until the feature has reached a stable interface.}
 }
}



\subtree[jms-00WL]{
 \title{intermediate representation of the XML format}
 \p{[[jms-005P]]’s primary output format is XML, rendered live in the browser to HTML using an XSLT stylesheet. Although this will continue to be the main output format, together with [[kentookura]] as well as our friends from [[toposinstitute]] I am hoping to explore richer [\em{hypermedia}](https://hypermedia.systems/) interfaces for [forests](tfmt-000R) that could transcend the limitations of static HTML output.}

 \p{In order to support multiple backends without creating a log of code churn, I have created an OCaml abstraction of the XML format that will serve as a “source of truth” for [[jms-005P]]’s output — which can be serialised directly to XML, or rendered in a different way (e.g. as HTML or [htmx](https://htmx.org/) emitted by a hypermedia server).}

 \p{With this change, I would expect [[jms-005P]]’s XML format to begin to change less and less over time, perhaps culminating in a versioned schema. I do not, however, guarantee that I will not make breaking changes to the format going forward.}
}


\subtree[jms-00WM]{
 \title{generalised backmatter}
 \import{base-macros}

 \p{Currently, the \em{backmatter} of a tree is not customisable; although the default backmatter sections are useful for most trees, it is likely that some of the sections are less relevant at times, and that other kinds of queries would be useful to be able to include on a tree-by-tree basis.}

 \p{In order to facilitate such a feature in the future, this release changes the representation of backmatter to support arbitrary content and queries. \mark{This is a breaking change to the XML format:} the \code{<backmatter>} element now contains arbitrary \code{<tree>} elements that encode the backmatter sections. By virtue of the [improved query engine](jms-00WS), all default backmatter sections are computed from queries.}
}

\subtree[jms-00WN]{
 \title{HTML figures and captions; embedded TeX}
 \p{This release adds \code{\verb<|\<figure} and \code{\verb<|\<figcaption} primitives that are interpreted by the XSLT stylesheet as HTML’s \code{<figure>} and \code{<figcaption>} elements.}

 \p{The stylesheet no longer emits the images corresponding to embedded #{\LaTeX} inside a \code{<center>} tag, as this is deprecated in HTML. Users are encouraged to wrap [[jms-005P]]’s \code{\verb<|\<tex} primitive in a macro that embeds a diagram in a figure. For example, the following code comes from my own macro preamble:}

 \pre\verb<<|
% Allocate a fluid binding to hold the default LaTeX preamble,
% e.g. for loading tikz packages.
\alloc\base/tex-preamble

\def\texfig[~body]{
 \scope{
  % Install a LaTeX preamble to be used by default if none is set.
  \put?\base/tex-preamble{
   % Some useful things from my own library.
   \latex-preamble/string-diagrams
   \latex-preamble/diagrams
  }

  % Wrap the diagram in a figure
  \figure{
   % Render the LaTeX code with the current preamble
   \tex{\get\base/tex-preamble}{\body{}}
  }
 }
}
 <<
}


\subtree[jms-00ZF]{
 \title{performance improvements in graph analysis}

 \p{The [previous graph implementation](http://backtracking.github.io/ocamlgraph/ocamlgraph/Graph/Imperative/Digraph/Concrete/index.html) has been replaced with [one that is more time-efficient](http://backtracking.github.io/ocamlgraph/ocamlgraph/Graph/Imperative/Digraph/ConcreteBidirectional/index.html) (at the cost of space). Computing the transclusion preorder (or, more generally, the reflexive-transitive closure of relations) is orders of magnitude faster; [my own forest](jms-0001) ultimately compiles in twice the speed.}
}
